<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content><title>iOS线程锁 | June</title><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS线程锁</h1><a id="logo" href="/blog/.">June</a><p class="description">王xx个人博客</p></div><div id="nav-menu"><a class="current" href="/blog/."><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a><a href="https://github.com/wsj2012"><i class="fa fa-rss"> GitHub</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS线程锁</h1><div class="post-meta">May 22, 2019</div><div class="post-content"><h1 id="iOS线程锁"><a href="#iOS线程锁" class="headerlink" title="iOS线程锁"></a>iOS线程锁</h1><blockquote>
<p>基本概念：为了保证共享数据操作的完整性和安全性而提出的一种机制。</p>
</blockquote>
<h2 id="为什么要使用？"><a href="#为什么要使用？" class="headerlink" title="为什么要使用？"></a>为什么要使用？</h2><p>为一个属性修饰为nonatomic的string对象赋值， 在并发队列中添加异步任务进行赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// @property (nonatomic, copy) NSString *target;</span><br><span class="line">- (void)lockTest &#123;</span><br><span class="line">		dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">		for (NSInteger i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">      dispatch_async(queue, ^&#123;</span><br><span class="line">        self.target = [NSString stringWithFormat:@&quot;target--%ld&quot;, i];</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果将会出现EXC_BAD_ACCESSd的crash问题。</p>
<p>先看看为target赋值操作的set内部方式实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setTarget:(NSString *)target &#123;</span><br><span class="line">		if (_target != target) &#123;</span><br><span class="line">			[_target release];</span><br><span class="line">			[_target retain];</span><br><span class="line">			_target = target;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是异步执行的，有些线程在执行到<code>[_target release]</code>的时候，对象已经被释放掉。同时另外其他某些线程也执行<code>[_target release]</code>的时候， 就会想一个已经释放的对象发送消息从而造成crash。</p>
<p>针对以上问题，提出了🔐的机制。在某一线程执行赋值操作时，先加锁，赋值结束后再解锁。其他线程无法访问已经加锁了的资源。</p>
<p>iOS提供了一下10中🔐：</p>
<h4 id="1、OSSpinLock-自旋锁"><a href="#1、OSSpinLock-自旋锁" class="headerlink" title="1、OSSpinLock(自旋锁)"></a>1、OSSpinLock(自旋锁)</h4><p>和互斥锁类似，为了保证线程安全。</p>
<p>互斥锁：当一个线程获取到这个锁后，其他想要获取此锁的线程将会被阻塞，直到该锁被释放。</p>
<p>自旋锁：当一个线程获得锁之后，其他线程将会一直循环在那里查看改锁是否被释放。原理就是一个do while循环。缺点是很消耗cpu资源，所以不适用于较长时间的任务，所以此锁较适用于持有者保存时间较短的情况下。正是由于此锁保持时间非常短，因为选择自旋锁而不是睡眠是非常必要的，自旋锁效率远高于互斥锁。</p>
<h4 id="2、os-unfair-lock"><a href="#2、os-unfair-lock" class="headerlink" title="2、os_unfair_lock"></a>2、os_unfair_lock</h4><p>自旋锁，苹果在iOS10.0以后用来替代OSSpinLock，需要导入头文件<code>#import &lt;os/lock.h&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">os_unfair_lock unfair_lock = OS_UNFAIR_LOCK_INIT</span><br><span class="line">// 加锁</span><br><span class="line">os_unfair_lock_lock(&amp;unfair_lock)</span><br><span class="line"> // 解锁</span><br><span class="line">os_unfair_lock_unlock(&amp;unfair_lock) </span><br><span class="line"> // 尝试加锁</span><br><span class="line">os_unfair_lock_trylock(&amp;unfair_lock)</span><br></pre></td></tr></table></figure>
<h4 id="3、dispatch-semaphore-信号量"><a href="#3、dispatch-semaphore-信号量" class="headerlink" title="3、dispatch_semaphore(信号量)"></a>3、dispatch_semaphore(信号量)</h4><p>GCD里面的信号量，实际上是通过限制并发线程的条数来控制线程安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 初始化   long value ：线程并发执行的数量</span><br><span class="line">dispatch_semaphore_t semaphore_t = dispatch_semaphore_create(1);</span><br><span class="line">// 加锁</span><br><span class="line">dispatch_semaphore_wait(semaphore_t,DISPATCH_TIME_FOREVER);</span><br><span class="line">// 解锁</span><br><span class="line">dispatch_semaphore_signal(semaphore_t);</span><br></pre></td></tr></table></figure>
<h4 id="4、pthread-mutex-互斥锁"><a href="#4、pthread-mutex-互斥锁" class="headerlink" title="4、pthread_mutex(互斥锁)"></a>4、pthread_mutex(互斥锁)</h4><p>当一个线程获得锁之后，其他想要获得此锁的线程将会被阻塞，知道到该锁被释放。</p>
<p>使用需引入头文件<code>#import &lt;pthread/pthread.h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//  初始化 ,提供两种方式</span><br><span class="line"></span><br><span class="line">// 第一种</span><br><span class="line">pthread_mutex_t mutex_t;</span><br><span class="line">pthread_mutex_init(&amp;mutex_t, NULL); </span><br><span class="line">// 第二种，宏初始化</span><br><span class="line">pthread_mutex_t mutex =PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">// 加锁</span><br><span class="line">pthread_mutex_lock(&amp;mutex_t);</span><br><span class="line">// 解锁</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_t);</span><br><span class="line">// 尝试加锁，这里和上面不同的是：当可以加锁返回的是 0，否则返回一个错误</span><br><span class="line">pthread_mutex_trylock(&amp; mutex_t)</span><br></pre></td></tr></table></figure>
<h4 id="5、NSLock-互斥锁、对象锁"><a href="#5、NSLock-互斥锁、对象锁" class="headerlink" title="5、NSLock(互斥锁、对象锁)"></a>5、NSLock(互斥锁、对象锁)</h4><p>此种锁使用较多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">NSLock *lock = [[NSLock alloc]init];</span><br><span class="line">// 加锁</span><br><span class="line">[lock lock];</span><br><span class="line">// 解锁</span><br><span class="line">[lock unlock];</span><br><span class="line">// 尝试加锁，可以加锁则立即加锁并返回 YES,反之返回 NO</span><br><span class="line">[lock tryLock];</span><br></pre></td></tr></table></figure>
<h4 id="6、NSCondition-条件锁、对象锁"><a href="#6、NSCondition-条件锁、对象锁" class="headerlink" title="6、NSCondition(条件锁、对象锁)"></a>6、NSCondition(条件锁、对象锁)</h4><p>互斥锁和条件锁的结合体。</p>
<p>NSCondition的对象实际充当线程中的锁和检查器。锁主要为了当检测条件时保护数据源；线程检查器主要是根据条件决定是否继续运行线程，即线程是否被阻塞。执行条件引发的任务当条件不成立时，线程会阻塞。在另一个线程向条件对象发出信号之前，它一直保持阻塞状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// // 初始化</span><br><span class="line">NSCondition *condition= [[NSCondition alloc]init];</span><br><span class="line">// 加锁</span><br><span class="line">[condition lock];</span><br><span class="line">// 解锁</span><br><span class="line">[condition unlock];</span><br><span class="line">/*</span><br><span class="line">其他功能</span><br><span class="line">wait 进入等待状态</span><br><span class="line">waitUntilDate:让一个线程等待一定的时间</span><br><span class="line">signal 唤醒一个等待的线程</span><br><span class="line">broadcast 唤醒所有等待的线程</span><br></pre></td></tr></table></figure>
<h4 id="7、NSConditionLock-条件锁、对象锁"><a href="#7、NSConditionLock-条件锁、对象锁" class="headerlink" title="7、NSConditionLock(条件锁、对象锁)"></a>7、NSConditionLock(条件锁、对象锁)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">NSConditionLock *_conditionLock = [[NSConditionLock alloc]init];</span><br><span class="line">// 加锁</span><br><span class="line">[_conditionLock lock];</span><br><span class="line">// 解锁</span><br><span class="line">[_conditionLock unlock];</span><br><span class="line">// 尝试加锁，可以加锁则立即加锁并返回 YES,反之返回 NO</span><br><span class="line">[_conditionLock tryLock];</span><br><span class="line">/*</span><br><span class="line">其他功能接口</span><br><span class="line">- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER; //初始化传入条件</span><br><span class="line">- (void)lockWhenCondition:(NSInteger)condition;//条件成立触发锁</span><br><span class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;//尝试条件成立触发锁</span><br><span class="line">- (void)unlockWithCondition:(NSInteger)condition;//条件成立解锁</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;//触发锁 在等待时间之内</span><br><span class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;//触发锁 条件成立 并且在等待时间之内</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="8、NSRecursiveLock-递归锁、对象锁"><a href="#8、NSRecursiveLock-递归锁、对象锁" class="headerlink" title="8、NSRecursiveLock(递归锁、对象锁)"></a>8、NSRecursiveLock(递归锁、对象锁)</h4><p>可以被同一线程多次请求，而不会引起死锁。同样只能有一个线程访问该对象，但允许同一个线程在未被释放其拥有的锁时可反复对该锁进行加锁操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">NSRecursiveLock *_recursiveLock = [[NSRecursiveLock alloc]init];</span><br><span class="line">// 加锁</span><br><span class="line">[_recursiveLock lock];</span><br><span class="line">// 解锁</span><br><span class="line">[_recursiveLock unlock];</span><br><span class="line">// 尝试加锁，可以加锁则立即加锁并返回 YES,反之返回 NO</span><br><span class="line">[_recursiveLock tryLock];</span><br><span class="line">/*</span><br><span class="line">注: 递归锁可以被同一线程多次请求，而不会引起死锁。</span><br><span class="line">即在同一线程中在未解锁之前还可以上锁, 执行锁中的代码。</span><br><span class="line">这主要是用在循环或递归操作中。</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;//触发锁 在等待时间之内</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="9、pthread-mutex-recursive-递归锁"><a href="#9、pthread-mutex-recursive-递归锁" class="headerlink" title="9、pthread_mutex(recursive)(递归锁)"></a>9、pthread_mutex(recursive)(递归锁)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">pthread_mutex_t mutex_t;</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr); //初始化attr并且给它赋予默认pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); //设置锁类型，这边是设置为递归锁</span><br><span class="line">pthread_mutex_init(&amp;mutex_t, &amp;attr);</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr); //销毁一个属性对象，在重新进行初始化之前该结构不能重新使用</span><br><span class="line">// 加锁</span><br><span class="line">pthread_mutex_lock(&amp;mutex_t);</span><br><span class="line">// 解锁</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_t);</span><br><span class="line">/*</span><br><span class="line">注: 递归锁可以被同一线程多次请求，而不会引起死锁。</span><br><span class="line">即在同一线程中在未解锁之前还可以上锁, 执行锁中的代码。</span><br><span class="line">这主要是用在循环或递归操作中。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="10、-synchronized-条件锁"><a href="#10、-synchronized-条件锁" class="headerlink" title="10、@synchronized(条件锁)"></a>10、@synchronized(条件锁)</h4><p>相比于使用 其他方式例如NSLock 创建锁对象、加锁和解锁来说，@synchronized 用着更方便，可读性更高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        begin = CACurrentMediaTime();</span><br><span class="line">        NSObject *lock = [NSObject new];</span><br><span class="line">        for(NSInteger i = 0;i &lt; count; i++)&#123;</span><br><span class="line">            dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">                @synchronized (lock) &#123;</span><br><span class="line">                    self.target = [NSString stringWithFormat:@&quot;target--%ld&quot;,i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">            end = CACurrentMediaTime();</span><br><span class="line">            NSLog(@&quot;@synchronized:           %8.2f ms&quot;,(end - begin) * 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/blog/tags/iOS/">iOS</a><a href="/blog/tags/线程锁/">线程锁</a><a href="/blog/tags/加锁/">加锁</a><a href="/blog/tags/安全/">安全</a></div><div class="post-nav"><a class="next" href="/blog/article/react生命周期/">react生命周期</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://wsj2012.github.io/blog"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/安全/" style="font-size: 15px;">安全</a> <a href="/blog/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/blog/tags/速度/" style="font-size: 15px;">速度</a> <a href="/blog/tags/App/" style="font-size: 15px;">App</a> <a href="/blog/tags/git/" style="font-size: 15px;">git</a> <a href="/blog/tags/命令/" style="font-size: 15px;">命令</a> <a href="/blog/tags/command/" style="font-size: 15px;">command</a> <a href="/blog/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/blog/tags/UI/" style="font-size: 15px;">UI</a> <a href="/blog/tags/线程锁/" style="font-size: 15px;">线程锁</a> <a href="/blog/tags/加锁/" style="font-size: 15px;">加锁</a> <a href="/blog/tags/启动/" style="font-size: 15px;">启动</a> <a href="/blog/tags/Flutter/" style="font-size: 15px;">Flutter</a> <a href="/blog/tags/工程/" style="font-size: 15px;">工程</a> <a href="/blog/tags/组件化/" style="font-size: 15px;">组件化</a> <a href="/blog/tags/react/" style="font-size: 15px;">react</a> <a href="/blog/tags/前端/" style="font-size: 15px;">前端</a> <a href="/blog/tags/h5/" style="font-size: 15px;">h5</a> <a href="/blog/tags/生命周期/" style="font-size: 15px;">生命周期</a> <a href="/blog/tags/OC/" style="font-size: 15px;">OC</a> <a href="/blog/tags/三角函数/" style="font-size: 15px;">三角函数</a> <a href="/blog/tags/圆/" style="font-size: 15px;">圆</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/article/iOS线程锁/">iOS线程锁</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/article/react生命周期/">react生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/article/App启动速度篇/">App启动速度篇</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/article/Flutter iOS风格UI框架搭建/">Flutter 纯iOS风格UI框架搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/article/git常用命令/">git常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/article/iOS组件化实现步骤总结/">iOS组件化实现步骤总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/article/EasySegmentedControl定制显示样式使用/">EasySegmentedControl定时显示样式使用说明</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/article/三角函数在绘制圆中的使用/">三角函数在绘制圆中的使用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/blog/." rel="nofollow">June.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/blog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/blog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/blog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/blog/js/smartresize.js?v=0.0.0"></script></div></body></html>