{"meta":{"title":"June","subtitle":"王xx个人博客","description":"","author":"wsj_2012","url":"https://wsj2012.github.io/blog","root":"/blog/"},"pages":[{"title":"","date":"2019-03-28T05:30:15.034Z","updated":"2019-03-28T02:38:10.158Z","comments":true,"path":"404.html","permalink":"https://wsj2012.github.io/blog/404.html","excerpt":"","text":""},{"title":"关于我","date":"2019-03-28T08:26:25.000Z","updated":"2019-04-26T08:03:25.063Z","comments":true,"path":"about/index.html","permalink":"https://wsj2012.github.io/blog/about/index.html","excerpt":"","text":"一句话学习一直在路上，用心记录走过的脚步。。。 关于我一个莫名其妙的，喜欢敲代码，喜欢研究技术的，表面上高冷、不苟言笑的， 偶尔又嬉皮笑脸，偶尔又特立独行的，双重性格的技术爱好者！ 兴趣方向大前端技术（包括iOS、h5技术），新技术实现等。 参与社区CSDN博客：https://blog.csdn.net/wlily6 GitHub：https://github.com/wsj2012 简书：https://www.jianshu.com/u/9be53b53e632 联系我Email： time_now@yeah.net"},{"title":"Tags","date":"2019-03-28T05:30:14.954Z","updated":"2019-03-28T02:38:10.393Z","comments":true,"path":"tags/index.html","permalink":"https://wsj2012.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"react生命周期","slug":"react生命周期","date":"2019-04-29T02:39:38.000Z","updated":"2019-04-29T02:53:00.282Z","comments":true,"path":"article/react生命周期/","link":"","permalink":"https://wsj2012.github.io/blog/article/react生命周期/","excerpt":"","text":"最近工作中使用到react.js进行前端页面开发，总是忘记react生命周期函数在什么时候调用，调用时间节点等问题。故Mark一下，以便在未来coding的时候忘记了能回来review。多看几遍相信就一定会记住。💪 初始化阶段： 1234567891011121314// 获取实例的默认属性getDefaultProps:// 设置属性的类型static propTypes // 组件即将首次被装载、渲染到页面上componentWillMount：// 组件在这里生成虚拟的 DOM 节点render:// 组件真正在被首次装载之后componentDidMount: 运行中状态： 1234567891011121314// 在数据更新页面需要重新渲染的时候，组件将要接收到属性的时候调用，componentWillReceiveProps:// 组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止render调用，后面的函数不会被继续执行了） shouldComponentUpdate:// 组件即将更新不能修改属性和状态componentWillUpdate:// 组件重新描绘render:// 组件已经更新componentDidUpdate: 销毁阶段： 12// 组件即将销毁componentWillUnmount:","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://wsj2012.github.io/blog/tags/react/"},{"name":"前端","slug":"前端","permalink":"https://wsj2012.github.io/blog/tags/前端/"},{"name":"h5","slug":"h5","permalink":"https://wsj2012.github.io/blog/tags/h5/"},{"name":"生命周期","slug":"生命周期","permalink":"https://wsj2012.github.io/blog/tags/生命周期/"}]},{"title":"App启动速度篇","slug":"App启动速度篇","date":"2019-04-26T09:42:45.000Z","updated":"2019-04-29T02:52:49.827Z","comments":true,"path":"article/App启动速度篇/","link":"","permalink":"https://wsj2012.github.io/blog/article/App启动速度篇/","excerpt":"","text":"1、App启动都做了哪些事儿？ 冷启动(启动前App进程不在系统里，需要系统新创建一个进程分配给它，这是一个完成的启动过程) 热启动(App进程在系统中，用户重新启动进入App的过程) 用户感知到启动慢，其实都发生在主线程上，而主线程慢的原因很多，如在主线程上执行了大文件的读写操作、在渲染周期中执行了大量计算等。。。 2、启动阶段 main()函数执行前； 优化： 1️⃣、减少动态库加载； 2️⃣、减少加载启动后不会去使用的类或者方法； 3️⃣、+loadn()方法里的内容可以放到首屏渲染完成后再执行，或者使用+initialize()方法替换掉 注：在一个+load()方法里，进行运行时替换操作带来4ms的消耗，文件越多，对启动速度的影响就越大。 main()函数执行后； 首屏渲染完成后。 3、启动优化 功能级别的启动优化（main()函数执行后阶段） 思路：main()函数执行后到首屏渲染完成只处理首屏相关的业务，其他非首屏业务的初始化、监听、配置文件读取等都放到首屏渲染完成后去做。 方法级别的启动优化 思路：检查首屏渲染完成前有哪些耗时的方法、将没必要的耗时方法滞后或异步执行(重点检查执行实现加载、编辑、存储图片和文件等资源的方法) 4、监控手段 定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时(Time Profiler) 对obj_msgSend方法进行hook来掌握所有方法的耗时。(fishhook) 注：FaceBook开源库fishhook，可在iOS上运行的Mach-O二进制文件中动态地重新绑定符号。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wsj2012.github.io/blog/tags/iOS/"},{"name":"App","slug":"App","permalink":"https://wsj2012.github.io/blog/tags/App/"},{"name":"启动","slug":"启动","permalink":"https://wsj2012.github.io/blog/tags/启动/"},{"name":"速度","slug":"速度","permalink":"https://wsj2012.github.io/blog/tags/速度/"}]},{"title":"Flutter 纯iOS风格UI框架搭建","slug":"Flutter iOS风格UI框架搭建","date":"2019-03-28T05:49:30.000Z","updated":"2019-04-29T02:52:54.456Z","comments":true,"path":"article/Flutter iOS风格UI框架搭建/","link":"","permalink":"https://wsj2012.github.io/blog/article/Flutter iOS风格UI框架搭建/","excerpt":"","text":"新入门Flutter技术栈，从iOS转入，故实现一套全iOS风格的Flutter页面搭建。其中通过查询官方资料(现在生态不够健全，资料很难寻找)，花了点功夫最终得以实现。有实现更好的方式还望不吝赐教，有使用不对的地方还请指正。 Fetures: 全使用iOS风格widget（CupertinoTabBar搭配CupertinoTabScaffold） tabBar上菜单可自由设置显示风格（包括图标、字体大小颜色） Attention: 此入口类CupertinoTabScaffold内未设置navigationBar， navigationBar最好都在各自page页内设置，这样可自定制navigationBar上显示的不同元素。（如果在此入口类设置了navigationBar，各tab首页page的navigationBar上显示元素就会一致，个性化定制各page的navigationBar就需要加入更多的逻辑，建议navigationBar分散到各自的page页去实现） main.dart123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import &apos;package:flutter/cupertino.dart&apos;;import &apos;package:myapp/src/EngwordsPage.dart&apos;;import &apos;package:myapp/src/SamplePage.dart&apos;;import &apos;package:myapp/src/FirstPage.dart&apos;;import &apos;package:myapp/src/ListPage.dart&apos;;void main() =&gt; runApp(new MyApp());class MyApp extends StatefulWidget &#123; @override _MyMainState createState() =&gt; new _MyMainState();&#125;class _MyMainState extends State&lt;MyApp&gt; &#123; // 默认索引第一个tab int _tabIndex = 0; // 正常情况的字体样式 final tabTextStyleNormal = new TextStyle(color: const Color(0xff969696)); // 选中情况的字体样式 final tabTextStyleSelect = new TextStyle(color: const Color(0xff63ca6c)); // 底部菜单栏图标数组 var tabImages; // 页面内容 var _pages; // 菜单文案 var tabTitles = [&apos;推荐&apos;, &apos;资讯&apos;, &apos;发现&apos;, &apos;我的&apos;]; // 路由map Map&lt;String, WidgetBuilder&gt; _routes = new Map(); // 生成image组件 Image getTabImage(path) &#123; return new Image.asset(path, width: 20.0, height: 20.0); &#125; void initData() &#123; if (tabImages == null) &#123; tabImages = [ [ getTabImage(&apos;assets/images/ic_nav_news_normal.png&apos;), getTabImage(&apos;assets/images/ic_nav_news_actived.png&apos;) ], [ getTabImage(&apos;assets/images/ic_nav_tweet_normal.png&apos;), getTabImage(&apos;assets/images/ic_nav_tweet_actived.png&apos;) ], [ getTabImage(&apos;assets/images/ic_nav_discover_normal.png&apos;), getTabImage(&apos;assets/images/ic_nav_discover_actived.png&apos;) ], [ getTabImage(&apos;assets/images/ic_nav_my_normal.png&apos;), getTabImage(&apos;assets/images/ic_nav_my_pressed.png&apos;) ] ]; &#125; _pages = [ new EngwordsPage(), new SamplePage(), new ListWidget(&quot;发现&quot;), new FirstPage() ]; //获取菜单栏字体样式 TextStyle getTabTextStyle(int curIndex) &#123; if (curIndex == _tabIndex) &#123; return tabTextStyleSelect; &#125; else &#123; return tabTextStyleNormal; &#125; &#125; // 获取图标 Image getTabIcon(int curIndex) &#123; if (curIndex == _tabIndex) &#123; return tabImages[curIndex][1]; &#125; return tabImages[curIndex][0]; &#125; // 获取标题文本 Text getTabTitle(int curIndex) &#123; return new Text( tabTitles[curIndex], style: getTabTextStyle(curIndex), ); &#125; // 获取BottomNavigationBarItem List&lt;BottomNavigationBarItem&gt; getBottomNavigationBarItem() &#123; List&lt;BottomNavigationBarItem&gt; list = new List(); for (int i = 0; i &lt; 4; i++) &#123; list.add(new BottomNavigationBarItem( icon: getTabIcon(i), title: getTabTitle(i))); &#125; return list; &#125; @override Widget build(BuildContext context) &#123; initData(); return new CupertinoApp( title: &quot;Demo&quot;, theme: new CupertinoThemeData( primaryColor: CupertinoColors.darkBackgroundGray, ), routes: _routes, home: new CupertinoTabScaffold( tabBar: CupertinoTabBar( items: getBottomNavigationBarItem(), currentIndex: _tabIndex, onTap: (index) &#123; setState(() &#123; _tabIndex = index; &#125;); &#125;, ), tabBuilder: (BuildContext context, int index) &#123; return CupertinoTabView( builder: (BuildContext context) &#123; return CupertinoPageScaffold( child: _pages[index], // navigationBar: CupertinoNavigationBar( // middle: Text(tabTitles[index]), // trailing: _trailingButtons[index], // ), ); &#125;, ); &#125;, ), ); &#125;&#125; FirstPage.dart12345678910111213141516171819202122232425262728293031323334353637import &apos;package:flutter/cupertino.dart&apos;;class FirstPage extends StatefulWidget &#123; @override FirstPageState createState() =&gt; new FirstPageState();&#125;class FirstPageState extends State&lt;FirstPage&gt; &#123; final rt = new CupertinoButton( child: new Image.asset(&quot;assets/images/nav_close.png&quot;), onPressed: () &#123; print(&quot;right clicked&quot;); &#125;, ); @override Widget build(BuildContext context) &#123; return new CupertinoPageScaffold( navigationBar: CupertinoNavigationBar( middle: Text(&quot;First&quot;), trailing: rt, border: Border.all(width: 0, color: CupertinoColors.darkBackgroundGray), ), child: new Container( child: new Center( child: new Text( &quot;这是第一个界面&quot;, style: new TextStyle( color: CupertinoColors.darkBackgroundGray, fontSize: 18, ), ), ), ), ); &#125;&#125; 其他类（EngwordsPage.dart、SamplePage.dart）都是如此的UI结构。 Effects：","categories":[],"tags":[{"name":"UI","slug":"UI","permalink":"https://wsj2012.github.io/blog/tags/UI/"},{"name":"iOS","slug":"iOS","permalink":"https://wsj2012.github.io/blog/tags/iOS/"},{"name":"App","slug":"App","permalink":"https://wsj2012.github.io/blog/tags/App/"},{"name":"Flutter","slug":"Flutter","permalink":"https://wsj2012.github.io/blog/tags/Flutter/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2018-03-28T09:59:02.000Z","updated":"2019-04-29T02:52:56.377Z","comments":true,"path":"article/git常用命令/","link":"","permalink":"https://wsj2012.github.io/blog/article/git常用命令/","excerpt":"","text":"Mark一下日常工作当中常用到的git命令： 1234567891011121314151617181920212223242526272829303132333435363738git stash 暂存文件git pull 拉取代码 git stash pop 从暂存区拉取代码git add *.m git commit -m “messages” 提交代码git pull —rebasegit push 推送代码到仓库git diff xxx.m 比较修改前后git branch 查看服务器分支名称git checkout branchname 切换分支git checkout xxx.m回滚一个文件git checkout .回滚全部git reset —hard 重置git clean -rf./fmanager pull -vgit branch -a 查看远程所有分支git branch 查看当前分支git branch master（本地分支名） origin/master（远程分支）----切换分支//回退全部代码git reset HEADgit clean -f// 直接克隆分支仓库到本地git clone -b yzt_live_20180921 http://git-ma.paic.com.cn/Toa/Fusion.gitpod lib lint --sources='https://git.oschina.net/ch_team/Specs.git,https://github.com/CocoaPods/Specs.git' --verboseUnable to find a pod with name, author, summary, or description matchingrm ~/Library/Caches/CocoaPods/search_index.jsonpod spec lint XSSchoolCommon.podspec --sources='https://git.oschina.net/ch_team/Specs.git,https://github.com/CocoaPods/Specs.git' --allow-warningspod setuppod lib lint --sources='http://git-ma.paic.com.cn/ToaApp/YZT-iOS-Pod-Spec.git,http://git-ma.paic.com.cn/ToaApp/YZT-iOS-Pod-Master.git' --allow-warnings --verbose","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://wsj2012.github.io/blog/tags/git/"},{"name":"命令","slug":"命令","permalink":"https://wsj2012.github.io/blog/tags/命令/"},{"name":"command","slug":"command","permalink":"https://wsj2012.github.io/blog/tags/command/"}]},{"title":"iOS组件化实现步骤总结","slug":"iOS组件化实现步骤总结","date":"2017-03-28T08:26:25.000Z","updated":"2019-04-29T02:52:58.225Z","comments":true,"path":"article/iOS组件化实现步骤总结/","link":"","permalink":"https://wsj2012.github.io/blog/article/iOS组件化实现步骤总结/","excerpt":"","text":"随着应用业务的增加，项目逐渐变得庞大，实施组件化方案就会显得尤为必要。网上的资料繁杂，介于有的表达不是特别清晰，这里记录个人实现iOS组件化的步骤，希望能帮助到你，解决在组件化过程中猜到的坑。 1、创建私有Repo（Specs） 在Git上创建一个Respository，并命名为Specs； 添加Private Pod并验证终端依次执行： 1234// 添加私有Repopod repo add ch_team https://git.oschina.net/ch_team/Specs.git// 验证是否成功pod repo lint . 2、创建主工程 在Git上创建一个Respository，并命名为PAToapAPP； 将Respository拉取下来并且通过XCodec创建工程，终端执行： 1git clone https://git.oschina.net/ch_team/PAToapAPP.git 终端切到PAToapAPP工程根目录下，初始化你的Podfile，此时不需要在Podfile添加任何依赖终端执行： 12pod initpod install 现在主工程已创建完毕。 3、创建组件Pod（创建多个Pod，创建方式相同） 在Git上创建Repository，并拉取到本地 1git clone https://git.oschina.net/ch_team/PAToapAPP-User.git 在PAToapAPP-User工程目录下，创建Example工程 创建.podspec，并且创建Pod/Classes目录， 将Example的View、ViewModel、Model拷贝至Classes目录1pod spec create PAToapAPP-User 文件目录变为：Example(📂)LICENSEPod(📃)……Classes(📂)…………Model(📂)…………View(📂)…………ViewModel(📂)README.mdPAToapAPP-User.podspec 修改.podspec文件 123s.homepage = \"http://git.oschina.net/ch_team/PAToapAPP-User\"s.license = &#123; :type =&gt; \"MIT\", :file =&gt; \"LICENSE\" &#125;s.source_files = \"Pod/Classes\", \"Pod/Classes/**/*.&#123;h,m&#125;\" 本地验证.podspec是否正确 1$ pod lib lint 提交到Github，并远程验证，按照下列步骤需要首先提交Git，然后添加Tag 1234567891011$ git add .$ git commit -m \"添加Pod\"$ git push#添加Tag$ git tag 0.0.1 #这里需要与你的.podspec中s.version值相同$ git push --tags#验证$ pod spec lint-&gt; PAToapAPP-User(0.0.1)Analyzed 1 podspecPAToapAPP-User.podspec passed validation. 添加Pod到你的私有的Repo中 12345678$ pod repo push ch_team PAToapAPP-User.podspecValidatiing spec-&gt;PAToapAPP-User(0.0.1)Updating the `ch_team` repoAlready up-to-date.Adding the spec to the `ch_team` repo-[No change] PAToapAPP-User(0.0.1)Pushing the `ch_team` repo 试试搜索你的Pod 1234$ pod search PAToapAPP-User-&gt;PAToapAPP-User(0.0.1)业务组件Apod 'PAToapAPP-User', '~&gt; 0.0.1' 现在你可以使用了，请记住在你的Podfile中添加你Private Pod 源 123456source 'https://github.com/CocoaPods/Specs' source 'https://github.com/ch_team/Specs.git' platform :ios, \"9.0\" target \"XXX\" do pod 'PAToapAPP-User', '~&gt;0.0.1' end 当组件化项目完成以后，后续开发中主要的操作步骤如下： 工程代码变更，进入podspec文件修改version版本号 git commit -am “修改说明”提交工程所有修改 pod repo push xxx xxx.podspec提交验证spec文件 在根目录的.cocoapods目录下去查看工程是否有对应版本信息","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wsj2012.github.io/blog/tags/iOS/"},{"name":"App","slug":"App","permalink":"https://wsj2012.github.io/blog/tags/App/"},{"name":"工程","slug":"工程","permalink":"https://wsj2012.github.io/blog/tags/工程/"},{"name":"组件化","slug":"组件化","permalink":"https://wsj2012.github.io/blog/tags/组件化/"}]},{"title":"EasySegmentedControl定时显示样式使用说明","slug":"EasySegmentedControl定制显示样式使用","date":"2016-03-28T06:16:16.000Z","updated":"2019-04-29T02:52:52.026Z","comments":true,"path":"article/EasySegmentedControl定制显示样式使用/","link":"","permalink":"https://wsj2012.github.io/blog/article/EasySegmentedControl定制显示样式使用/","excerpt":"","text":"EasySegmentedControl是HMSegmentedControl的swift版本，两个库的实现细节及实现方式是一致的，鉴于里面有很多属性参数的设置，第一次使用此库的人对有的参数使用不是很明白，各参数使用对定制样式实际作用不会很熟悉，故写此文，可以更好的帮助你使用此第三方库，灵活地定制出自己想要的样式。此文提供五种样式Demo，可在此五种样式上灵活调整参数，以定制出不同样式的分段控制器。 接入方式可选择如下方式中的一种： pod ‘EasySegmentedControl’ 将EasySegmentedControl.swift文件导入自己的工程 Demo①Style1： 效果图 1234567let viewWidth = view.frame.size.width let sc = EasySegmentedControl.init(with: [\"Trending\", \"News\", \"Library\"]) sc.frame = CGRect(x: 0, y: 88, width: viewWidth, height: 40) sc.autoresizingMask = [.flexibleRightMargin, .flexibleWidth] sc.backgroundsColor = UIColor.clear sc.addTarget(self, action: #selector(segmentedControlChangedValue(segmentedControl:)), for: .valueChanged) view.addSubview(sc) Demo②Style2： Code: 123456789101112131415let sc1 = EasySegmentedControl.init(with: [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\"]) sc1.autoresizingMask = [.flexibleRightMargin, .flexibleWidth] sc1.frame = CGRect(x: 0, y: 60 + 68, width: viewWidth, height: 40) sc1.segmentEdgeInset = UIEdgeInsets(top: 0, left: 10, bottom: 0, right: 10) sc1.selectionStyle = .FullWidthStripe sc1.selectionIndicatorLocation = .Down sc1.verticalDividerEnabled = true sc1.verticalDividerColor = .black sc1.verticalDividerWidth = 1.0 sc1.titleFormatter = &#123;(seg, title, index, selected) in let attString = NSAttributedString.init(string: title, attributes: [NSAttributedString.Key.foregroundColor : UIColor.blue]) return attString &#125; sc1.addTarget(self, action: #selector(segmentedControlChangedValue(segmentedControl:)), for: .valueChanged) view.addSubview(sc1) Demo③Style3： Code: 1234567891011121314151617sc1.addTarget(self, action: #selector(segmentedControlChangedValue(segmentedControl:)), for: .valueChanged)view.addSubview(sc1)// Segmented control with imageslet images: [UIImage] = [UIImage(named: \"1\")!, UIImage(named: \"2\")!, UIImage(named: \"3\")!, UIImage(named: \"4\")!]let selectedImages: [UIImage] = [UIImage(named: \"1-selected\")!, UIImage(named: \"2-selected\")!, UIImage(named: \"3-selected\")!, UIImage(named: \"4-selected\")!]let titles: [String] = [\"1\", \"2\", \"3\", \"4\"]let sc2 = EasySegmentedControl.init(with: images, sectionSelectedImages: selectedImages, sectiontitles: titles)sc2.imagePosition = .LeftOfTextsc2.frame = CGRect(x: 0, y: 120 + 68, width: viewWidth, height: 50)sc2.selectionIndicatorHeight = 4.0sc2.backgroundsColor = UIColor.clearsc2.selectionIndicatorLocation = .Downsc2.selectionStyle = .TextWidthStripesc2.segmentWidthStyle = .Dynamicsc2.addTarget(self, action: #selector(segmentedControlChangedValue(segmentedControl:)), for: .valueChanged)view.addSubview(sc2) Demo④Style4： Code: 1234567891011121314151617let sc3 = EasySegmentedControl.init(with: [\"one\", \"Two\", \"Three\", \"4\", \"Five\"]) sc3.frame = CGRect(x: 0, y: 180 + 68, width: viewWidth, height: 50) sc3.indexChangeBlock = &#123; index in print(\"Selected index \\(index) (via block)\") &#125; sc3.selectionIndicatorHeight = 4.0 sc3.backgroundsColor = UIColor(red: 0.1, green: 0.4, blue: 0.8, alpha: 1) sc3.titleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white] sc3.selectionIndicatorColor = UIColor(red: 0.5, green: 0.8, blue: 1, alpha: 1) sc3.selectionIndicatorBoxColor = UIColor.black sc3.selectionIndicatorBoxOpacity = 1.0 sc3.selectionStyle = .Box sc3.selectedSegmentIndex = NoSegment sc3.selectionIndicatorLocation = .Down sc3.shouldAnimateUserSelection = false sc3.tag = 2 view.addSubview(sc3) Demo⑤Style5： Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253lazy var scrollView: UIScrollView = &#123; let s = UIScrollView.init(frame: CGRect(x: 0, y: 310 + 68, width: view.frame.size.width, height: 210)) s.backgroundColor = UIColor(red: 0.7, green: 0.7, blue: 0.7, alpha: 1) s.isPagingEnabled = true s.showsHorizontalScrollIndicator = false s.contentSize = CGSize(width: view.frame.size.width * 3, height: 200) s.delegate = self s.scrollRectToVisible(CGRect(x: view.frame.size.width, y: 0, width: view.frame.size.width, height: 200), animated: false) return s&#125;()override func viewDidLoad() &#123; super.viewDidLoad() let sc4 = EasySegmentedControl.init(frame: CGRect(x: 0, y: 260 + 68, width: view.frame.size.width, height: 50)) sc4.sectionTitles = [\"Worldwide\", \"Local\", \"Headlines\"] sc4.selectedSegmentIndex = 1 sc4.backgroundColor = UIColor(red: 0.7, green: 0.7, blue: 0.7, alpha: 1) sc4.titleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white] sc4.selectedTitleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor(red: 0.1, green: 0.1, blue: 0.1, alpha: 1)] sc4.selectionIndicatorColor = UIColor(red: 0.3, green: 0.3, blue: 0.3, alpha: 1) sc4.selectionStyle = .Box; sc4.selectionIndicatorLocation = .Up; sc4.tag = 3; sc4.indexChangeBlock = &#123;[weak self] index in if let strongSelf = self &#123; strongSelf.scrollView.scrollRectToVisible(CGRect(x: viewWidth * CGFloat(index), y: 0, width: viewWidth, height: 200), animated: true) &#125; &#125; view.addSubview(sc4) let lable1 = UILabel.init(frame: CGRect(x: 0, y: 0, width: viewWidth, height: 210)) setApperanceFor(label: lable1) lable1.text = \"Worldwide\" scrollView.addSubview(lable1) let lable2 = UILabel.init(frame: CGRect(x: viewWidth, y: 0, width: viewWidth, height: 210)) setApperanceFor(label: lable2) lable2.text = \"Local\" scrollView.addSubview(lable2) let lable3 = UILabel.init(frame: CGRect(x: viewWidth * 2, y: 0, width: viewWidth, height: 210)) setApperanceFor(label: lable3) lable3.text = \"Headlines\" scrollView.addSubview(lable3)&#125;func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123; let pageWidth = scrollView.frame.size.width let page = Int(scrollView.contentOffset.x / pageWidth) sc4.setSelectedSegment(index: page, animated: true)&#125; 您可根据自己的需要，调整参数达到UI设计的样式规范。","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://wsj2012.github.io/blog/tags/Swift/"},{"name":"UI","slug":"UI","permalink":"https://wsj2012.github.io/blog/tags/UI/"},{"name":"iOS","slug":"iOS","permalink":"https://wsj2012.github.io/blog/tags/iOS/"},{"name":"App","slug":"App","permalink":"https://wsj2012.github.io/blog/tags/App/"}]},{"title":"三角函数在绘制圆中的使用","slug":"三角函数在绘制圆中的使用","date":"2015-03-29T05:35:24.000Z","updated":"2019-04-29T02:59:11.311Z","comments":true,"path":"article/三角函数在绘制圆中的使用/","link":"","permalink":"https://wsj2012.github.io/blog/article/三角函数在绘制圆中的使用/","excerpt":"","text":"在绘制饼图百分比图例标识类的图形中，我们就需要用到三角函数相关的知识点来计算各个点的位置，这里实现了一个简单的饼图百分比图例标识的example，通过此例可举一反三结合实际项目中的需求，实现其所需要的效果。希望你能通过此例能有所收获。此例子为Objective-C版本。 直接上代码：新建一个继承自UIView的对象： .h文件： 1234567891011121314151617// // PieView.h // BlurDemo // // Created by sj_w on 15/9/11. // Copyright (c) 2015年 sj_w. All rights reserved. // #import &lt;UIKit/UIKit.h&gt; @interface PieView : UIView @property (nonatomic, strong) NSArray *percentArr;//百分比分段 @property (nonatomic, strong) NSMutableArray *angleArr;//对应的弧度 @property (nonatomic, strong) NSMutableArray *midAngleArr;//每个弧度分段的中心点位置 @end .m文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// // PieView.m // BlurDemo // // Created by sj_w on 15/9/11. // Copyright (c) 2015年 sj_w. All rights reserved. // #import &quot;PieView.h&quot; #define kScreenWidth [UIScreen mainScreen].bounds.size.width #define OUTR ((kScreenWidth)/4) #define INR ((kScreenWidth/4)-26) #define PIECENTERX kScreenWidth/2 #define PIECENTERY 150 #define PIECENTER CGPointMake(kScreenWidth/2, frame.size.height/2) #define LABELTAG 121 @implementation PieView - (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; self.frame = frame; self.backgroundColor = [UIColor orangeColor]; [self initArr]; [self initSubviews]; &#125; return self; &#125; - (void)initSubviews &#123; NSArray *titleArr = @[@&quot;现金类&quot;,@&quot;固定收益类&quot;,@&quot;股票类&quot;]; NSArray *subTitleArr = @[@&quot;30%&quot;,@&quot;60%&quot;,@&quot;10%&quot;]; for (int i = 0; i &lt; self.percentArr.count; i++) &#123; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(-100, -100, 100, 100)]; label.font = [UIFont systemFontOfSize:16]; label.text = [NSString stringWithFormat:@&quot;%@\\n%@&quot;,titleArr[i],subTitleArr[i]]; label.textColor = [UIColor whiteColor]; label.textAlignment = NSTextAlignmentCenter; label.numberOfLines = 0; label.lineBreakMode = NSLineBreakByCharWrapping; label.tag = LABELTAG+i; [self addSubview:label]; &#125; &#125; - (void)initArr &#123; self.percentArr = @[@0.3,@0.6,@0.1]; self.angleArr = [[NSMutableArray alloc] initWithCapacity:self.percentArr.count]; self.midAngleArr = [[NSMutableArray alloc] initWithCapacity:self.percentArr.count]; float sumAngle = 0.0; //通过百分比转换成弧度 for (int i = 0; i &lt; self.percentArr.count; i++) &#123; CGFloat angle = [self.percentArr[i] floatValue]*2*M_PI; CGFloat midAngle = sumAngle + angle/2.0; [self.midAngleArr addObject:[NSNumber numberWithFloat:midAngle]]; sumAngle += angle; [self.angleArr addObject:[NSNumber numberWithFloat:sumAngle]]; &#125; &#125; // Only override drawRect: if you perform custom drawing. // An empty implementation adversely affects performance during animation. - (void)drawRect:(CGRect)rect &#123; //绘制外圆填充绿色 CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [UIColor greenColor].CGColor); CGContextAddArc(context, kScreenWidth/2, 150, OUTR, 0, 2*M_PI, 0); CGContextFillPath(context); //绘制外圆设置颜色为白色 CGContextSetLineWidth(context, 2); CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor); CGContextAddArc(context, PIECENTERX, PIECENTERY, OUTR, 0, 2*M_PI, 0); CGContextStrokePath(context); //绘制内圆填充色为橙色 CGContextSetFillColorWithColor(context, [UIColor orangeColor].CGColor); CGContextAddArc(context, PIECENTERX, PIECENTERY, INR, 0, 2*M_PI, 0); CGContextFillPath(context); //绘制内圆颜色为白色 CGContextSetLineWidth(context, 2); CGContextAddArc(context, PIECENTERX, PIECENTERY, INR, 0, 2*M_PI, 0); CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor); CGContextStrokePath(context); for (int i = 0; i &lt; self.angleArr.count; i++) &#123; //根据弧度算内分割的线的起始点 CGFloat angle = [self.angleArr[i] floatValue]; CGPoint inPoint = CGPointMake(PIECENTERX+INR*cos(angle), PIECENTERY+INR*sin(angle)); CGPoint outPoint = CGPointMake(PIECENTERX+OUTR*cos(angle), PIECENTERY+OUTR*sin(angle)); //连接起始点 CGContextSetLineWidth(context, 2.0); CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor); CGContextMoveToPoint(context, inPoint.x, inPoint.y); CGContextAddLineToPoint(context, outPoint.x, outPoint.y); CGContextStrokePath(context); //算每个分段弧度的中心点位置 CGFloat midAngel = [self.midAngleArr[i] floatValue]; CGPoint midPoint = CGPointMake(PIECENTERX+(INR+OUTR)/2.0*cos(midAngel), PIECENTERY+(INR+OUTR)/2.0*sin(midAngel)); // CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); // CGContextAddArc(context, midPoint.x, midPoint.y, 3, 0, 2*M_PI, 0); // CGContextFillPath(context); //每个分段延伸出去的折点 CGPoint breakPoint = CGPointMake(PIECENTERX+(OUTR+(OUTR-INR)/2.0)*cos(midAngel), PIECENTERY+(OUTR+(OUTR-INR)/2.0)*sin(midAngel)); // CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); // CGContextAddArc(context, breakPoint.x, breakPoint.y, 3, 0, 2*M_PI, 0); // CGContextFillPath(context); //结束点的位置，确定说明文本的放置位置 CGPoint endPoint; if (breakPoint.x&lt;PIECENTERX) &#123; endPoint = CGPointMake(43, breakPoint.y); &#125;else &#123; endPoint = CGPointMake(kScreenWidth-43, breakPoint.y); &#125; //结束点画圈，填充白色 CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); CGContextAddArc(context, endPoint.x, endPoint.y, 3, 0, 2*M_PI, 0); CGContextFillPath(context); //将中心点、折点、结束点连接起来 CGContextSetLineWidth(context, 2.0); CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor); CGContextMoveToPoint(context, midPoint.x, midPoint.y); CGContextAddLineToPoint(context, breakPoint.x, breakPoint.y); CGContextAddLineToPoint(context, endPoint.x, endPoint.y); CGContextSetLineCap(context, kCGLineCapRound); CGContextStrokePath(context); // CGContextSetLineWidth(context, 2.0f); // CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor); // CGContextMoveToPoint(context, midPoint.x, midPoint.y); // CGContextSetLineCap(context, kCGLineCapRound); // CGContextAddLineToPoint(context, breakPoint.x, breakPoint.y); // CGContextStrokePath(context); //调整说明控件的中心位置 UILabel *label = (UILabel *)[self viewWithTag:LABELTAG+i]; label.center = CGPointMake(endPoint.x, endPoint.y+30); &#125; &#125; @end 最终效果图：","categories":[],"tags":[{"name":"UI","slug":"UI","permalink":"https://wsj2012.github.io/blog/tags/UI/"},{"name":"iOS","slug":"iOS","permalink":"https://wsj2012.github.io/blog/tags/iOS/"},{"name":"App","slug":"App","permalink":"https://wsj2012.github.io/blog/tags/App/"},{"name":"OC","slug":"OC","permalink":"https://wsj2012.github.io/blog/tags/OC/"},{"name":"三角函数","slug":"三角函数","permalink":"https://wsj2012.github.io/blog/tags/三角函数/"},{"name":"圆","slug":"圆","permalink":"https://wsj2012.github.io/blog/tags/圆/"}]}]}