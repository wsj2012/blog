{"meta":{"title":"wsj_2012","subtitle":"个人博客","description":"","author":"wsj_2012","url":"https://wsj2012.github.io/blog","root":"/blog/"},"pages":[{"title":"","date":"2019-03-28T05:30:15.034Z","updated":"2019-03-28T02:38:10.158Z","comments":true,"path":"404.html","permalink":"https://wsj2012.github.io/blog/404.html","excerpt":"","text":""},{"title":"关于我","date":"2019-03-28T08:26:25.000Z","updated":"2019-04-26T07:17:05.062Z","comments":true,"path":"about/index.html","permalink":"https://wsj2012.github.io/blog/about/index.html","excerpt":"","text":"一句话 Where there is a will there is a way! 关于我 一个莫名其妙的，喜欢敲代码，喜欢研究技术的，表面上高冷、不苟言笑的， 偶尔又嬉皮笑脸，偶尔又特立独行的，双重性格的技术爱好者！ 兴趣方向 大前端技术（包括iOS、h5技术），新技术实现等。 参与社区 CSDN博客:https://blog.csdn.net/wlily6 Github:https://github.com/wsj2012 简书:https://www.jianshu.com/u/9be53b53e632 联系我 Email: time_now@yeah.net"},{"title":"Tags","date":"2019-03-28T05:30:14.954Z","updated":"2019-03-28T02:38:10.393Z","comments":true,"path":"tags/index.html","permalink":"https://wsj2012.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"三角函数在绘制圆中的使用","slug":"三角函数在绘制圆中的使用","date":"2019-03-29T05:35:24.000Z","updated":"2019-04-26T07:31:22.254Z","comments":true,"path":"article/三角函数在绘制圆中的使用/","link":"","permalink":"https://wsj2012.github.io/blog/article/三角函数在绘制圆中的使用/","excerpt":"","text":"在绘制饼图百分比图例标识类的图形中，我们就需要用到三角函数相关的知识点来计算各个点的位置，这里实现了一个简单的饼图百分比图例标识的example，通过此例可举一反三结合实际项目中的需求，实现其所需要的效果。希望你能通过此例能有所收获。此例子为Objective-C版本。 直接上代码：新建一个继承自UIView的对象： .h文件：1234567891011121314151617// // PieView.h // BlurDemo // // Created by sj_w on 15/9/11. // Copyright (c) 2015年 sj_w. All rights reserved. // #import &lt;UIKit/UIKit.h&gt; @interface PieView : UIView @property (nonatomic, strong) NSArray *percentArr;//百分比分段 @property (nonatomic, strong) NSMutableArray *angleArr;//对应的弧度 @property (nonatomic, strong) NSMutableArray *midAngleArr;//每个弧度分段的中心点位置 @end .m文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// // PieView.m // BlurDemo // // Created by sj_w on 15/9/11. // Copyright (c) 2015年 sj_w. All rights reserved. // #import &quot;PieView.h&quot; #define kScreenWidth [UIScreen mainScreen].bounds.size.width #define OUTR ((kScreenWidth)/4) #define INR ((kScreenWidth/4)-26) #define PIECENTERX kScreenWidth/2 #define PIECENTERY 150 #define PIECENTER CGPointMake(kScreenWidth/2, frame.size.height/2) #define LABELTAG 121 @implementation PieView - (id)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; self.frame = frame; self.backgroundColor = [UIColor orangeColor]; [self initArr]; [self initSubviews]; &#125; return self; &#125; - (void)initSubviews &#123; NSArray *titleArr = @[@&quot;现金类&quot;,@&quot;固定收益类&quot;,@&quot;股票类&quot;]; NSArray *subTitleArr = @[@&quot;30%&quot;,@&quot;60%&quot;,@&quot;10%&quot;]; for (int i = 0; i &lt; self.percentArr.count; i++) &#123; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(-100, -100, 100, 100)]; label.font = [UIFont systemFontOfSize:16]; label.text = [NSString stringWithFormat:@&quot;%@\\n%@&quot;,titleArr[i],subTitleArr[i]]; label.textColor = [UIColor whiteColor]; label.textAlignment = NSTextAlignmentCenter; label.numberOfLines = 0; label.lineBreakMode = NSLineBreakByCharWrapping; label.tag = LABELTAG+i; [self addSubview:label]; &#125; &#125; - (void)initArr &#123; self.percentArr = @[@0.3,@0.6,@0.1]; self.angleArr = [[NSMutableArray alloc] initWithCapacity:self.percentArr.count]; self.midAngleArr = [[NSMutableArray alloc] initWithCapacity:self.percentArr.count]; float sumAngle = 0.0; //通过百分比转换成弧度 for (int i = 0; i &lt; self.percentArr.count; i++) &#123; CGFloat angle = [self.percentArr[i] floatValue]*2*M_PI; CGFloat midAngle = sumAngle + angle/2.0; [self.midAngleArr addObject:[NSNumber numberWithFloat:midAngle]]; sumAngle += angle; [self.angleArr addObject:[NSNumber numberWithFloat:sumAngle]]; &#125; &#125; // Only override drawRect: if you perform custom drawing. // An empty implementation adversely affects performance during animation. - (void)drawRect:(CGRect)rect &#123; //绘制外圆填充绿色 CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [UIColor greenColor].CGColor); CGContextAddArc(context, kScreenWidth/2, 150, OUTR, 0, 2*M_PI, 0); CGContextFillPath(context); //绘制外圆设置颜色为白色 CGContextSetLineWidth(context, 2); CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor); CGContextAddArc(context, PIECENTERX, PIECENTERY, OUTR, 0, 2*M_PI, 0); CGContextStrokePath(context); //绘制内圆填充色为橙色 CGContextSetFillColorWithColor(context, [UIColor orangeColor].CGColor); CGContextAddArc(context, PIECENTERX, PIECENTERY, INR, 0, 2*M_PI, 0); CGContextFillPath(context); //绘制内圆颜色为白色 CGContextSetLineWidth(context, 2); CGContextAddArc(context, PIECENTERX, PIECENTERY, INR, 0, 2*M_PI, 0); CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor); CGContextStrokePath(context); for (int i = 0; i &lt; self.angleArr.count; i++) &#123; //根据弧度算内分割的线的起始点 CGFloat angle = [self.angleArr[i] floatValue]; CGPoint inPoint = CGPointMake(PIECENTERX+INR*cos(angle), PIECENTERY+INR*sin(angle)); CGPoint outPoint = CGPointMake(PIECENTERX+OUTR*cos(angle), PIECENTERY+OUTR*sin(angle)); //连接起始点 CGContextSetLineWidth(context, 2.0); CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor); CGContextMoveToPoint(context, inPoint.x, inPoint.y); CGContextAddLineToPoint(context, outPoint.x, outPoint.y); CGContextStrokePath(context); //算每个分段弧度的中心点位置 CGFloat midAngel = [self.midAngleArr[i] floatValue]; CGPoint midPoint = CGPointMake(PIECENTERX+(INR+OUTR)/2.0*cos(midAngel), PIECENTERY+(INR+OUTR)/2.0*sin(midAngel)); // CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); // CGContextAddArc(context, midPoint.x, midPoint.y, 3, 0, 2*M_PI, 0); // CGContextFillPath(context); //每个分段延伸出去的折点 CGPoint breakPoint = CGPointMake(PIECENTERX+(OUTR+(OUTR-INR)/2.0)*cos(midAngel), PIECENTERY+(OUTR+(OUTR-INR)/2.0)*sin(midAngel)); // CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); // CGContextAddArc(context, breakPoint.x, breakPoint.y, 3, 0, 2*M_PI, 0); // CGContextFillPath(context); //结束点的位置，确定说明文本的放置位置 CGPoint endPoint; if (breakPoint.x&lt;PIECENTERX) &#123; endPoint = CGPointMake(43, breakPoint.y); &#125;else &#123; endPoint = CGPointMake(kScreenWidth-43, breakPoint.y); &#125; //结束点画圈，填充白色 CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); CGContextAddArc(context, endPoint.x, endPoint.y, 3, 0, 2*M_PI, 0); CGContextFillPath(context); //将中心点、折点、结束点连接起来 CGContextSetLineWidth(context, 2.0); CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor); CGContextMoveToPoint(context, midPoint.x, midPoint.y); CGContextAddLineToPoint(context, breakPoint.x, breakPoint.y); CGContextAddLineToPoint(context, endPoint.x, endPoint.y); CGContextSetLineCap(context, kCGLineCapRound); CGContextStrokePath(context); // CGContextSetLineWidth(context, 2.0f); // CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor); // CGContextMoveToPoint(context, midPoint.x, midPoint.y); // CGContextSetLineCap(context, kCGLineCapRound); // CGContextAddLineToPoint(context, breakPoint.x, breakPoint.y); // CGContextStrokePath(context); //调整说明控件的中心位置 UILabel *label = (UILabel *)[self viewWithTag:LABELTAG+i]; label.center = CGPointMake(endPoint.x, endPoint.y+30); &#125; &#125; @end 最终效果图：","categories":[],"tags":[{"name":"UI","slug":"UI","permalink":"https://wsj2012.github.io/blog/tags/UI/"},{"name":"iOS","slug":"iOS","permalink":"https://wsj2012.github.io/blog/tags/iOS/"},{"name":"App","slug":"App","permalink":"https://wsj2012.github.io/blog/tags/App/"},{"name":"OC","slug":"OC","permalink":"https://wsj2012.github.io/blog/tags/OC/"},{"name":"三角函数","slug":"三角函数","permalink":"https://wsj2012.github.io/blog/tags/三角函数/"},{"name":"圆","slug":"圆","permalink":"https://wsj2012.github.io/blog/tags/圆/"}]},{"title":"iOS组件化实现步骤总结","slug":"iOS组件化实现步骤总结","date":"2019-03-28T08:26:25.000Z","updated":"2019-04-26T07:26:49.825Z","comments":true,"path":"article/iOS组件化实现步骤总结/","link":"","permalink":"https://wsj2012.github.io/blog/article/iOS组件化实现步骤总结/","excerpt":"","text":"======== 1、创建私有Repo（Specs） 在Git上创建一个Respository，并命名为Specs； 添加Private Pod并验证终端依次执行： 1234// 添加私有Repopod repo add ch_team https://git.oschina.net/ch_team/Specs.git// 验证是否成功pod repo lint . 2、创建主工程 在Git上创建一个Respository，并命名为PAToapAPP； 将Respository拉取下来并且通过XCodec创建工程，终端执行： 1git clone https://git.oschina.net/ch_team/PAToapAPP.git 终端切到PAToapAPP工程根目录下，初始化你的Podfile，此时不需要在Podfile添加任何依赖终端执行： 12pod initpod install 现在主工程已创建完毕。 3、创建组件Pod（创建多个Pod，创建方式相同） 在Git上创建Repository，并拉取到本地 1git clone https://git.oschina.net/ch_team/PAToapAPP-User.git 在PAToapAPP-User工程目录下，创建Example工程 创建.podspec，并且创建Pod/Classes目录， 将Example的View、ViewModel、Model拷贝至Classes目录1pod spec create PAToapAPP-User 文件目录变为：Example(📂)LICENSEPod(📃)……Classes(📂)…………Model(📂)…………View(📂)…………ViewModel(📂)README.mdPAToapAPP-User.podspec 修改.podspec文件 123s.homepage = &quot;http://git.oschina.net/ch_team/PAToapAPP-User&quot;s.license = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125;s.source_files = &quot;Pod/Classes&quot;, &quot;Pod/Classes/**/*.&#123;h,m&#125;&quot; 本地验证.podspec是否正确 1$ pod lib lint 提交到Github，并远程验证，按照下列步骤需要首先提交Git，然后添加Tag 1234567891011$ git add .$ git commit -m &quot;添加Pod&quot;$ git push#添加Tag$ git tag 0.0.1 #这里需要与你的.podspec中s.version值相同$ git push --tags#验证$ pod spec lint-&gt; PAToapAPP-User(0.0.1)Analyzed 1 podspecPAToapAPP-User.podspec passed validation. 添加Pod到你的私有的Repo中 12345678$ pod repo push ch_team PAToapAPP-User.podspecValidatiing spec-&gt;PAToapAPP-User(0.0.1)Updating the `ch_team` repoAlready up-to-date.Adding the spec to the `ch_team` repo-[No change] PAToapAPP-User(0.0.1)Pushing the `ch_team` repo 试试搜索你的Pod 1234$ pod search PAToapAPP-User-&gt;PAToapAPP-User(0.0.1)业务组件Apod &apos;PAToapAPP-User&apos;, &apos;~&gt; 0.0.1&apos; 现在你可以使用了，请记住在你的Podfile中添加你Private Pod 源 123456source &apos;https://github.com/CocoaPods/Specs&apos; source &apos;https://github.com/ch_team/Specs.git&apos; platform :ios, &quot;9.0&quot; target &quot;XXX&quot; do pod &apos;PAToapAPP-User&apos;, &apos;~&gt;0.0.1&apos; end 当组件化项目完成以后，后续开发中主要的操作步骤如下： 工程代码变更，进入podspec文件修改version版本号 git commit -am “修改说明”提交工程所有修改 pod repo push xxx xxx.podspec提交验证spec文件 在根目录的.cocoapods目录下去查看工程是否有对应版本信息","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://wsj2012.github.io/blog/tags/iOS/"},{"name":"App","slug":"App","permalink":"https://wsj2012.github.io/blog/tags/App/"},{"name":"工程","slug":"工程","permalink":"https://wsj2012.github.io/blog/tags/工程/"},{"name":"组件化","slug":"组件化","permalink":"https://wsj2012.github.io/blog/tags/组件化/"}]},{"title":"EasySegmentedControl定时显示样式使用说明","slug":"EasySegmentedControl定制显示样式使用","date":"2019-03-28T06:16:16.000Z","updated":"2019-04-26T06:51:13.817Z","comments":true,"path":"article/EasySegmentedControl定制显示样式使用/","link":"","permalink":"https://wsj2012.github.io/blog/article/EasySegmentedControl定制显示样式使用/","excerpt":"","text":"EasySegmentedControl是HMSegmentedControl的swift版本，两个库的实现细节及实现方式是一致的，鉴于里面有很多属性参数的设置，第一次使用此库的人对有的参数使用不是很明白，各参数使用对定制样式实际作用不会很熟悉，故写此文，可以更好的帮助你使用此第三方库，灵活地定制出自己想要的样式。此文提供五种样式Demo，可在此五种样式上灵活调整参数，以定制出不同样式的分段控制器。 接入方式可选择如下方式中的一种： pod ‘EasySegmentedControl’ 将EasySegmentedControl.swift文件导入自己的工程 Demo①Style1： 效果图 1234567let viewWidth = view.frame.size.width let sc = EasySegmentedControl.init(with: [&quot;Trending&quot;, &quot;News&quot;, &quot;Library&quot;]) sc.frame = CGRect(x: 0, y: 88, width: viewWidth, height: 40) sc.autoresizingMask = [.flexibleRightMargin, .flexibleWidth] sc.backgroundsColor = UIColor.clear sc.addTarget(self, action: #selector(segmentedControlChangedValue(segmentedControl:)), for: .valueChanged) view.addSubview(sc) Demo②Style2： Code: 123456789101112131415let sc1 = EasySegmentedControl.init(with: [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;]) sc1.autoresizingMask = [.flexibleRightMargin, .flexibleWidth] sc1.frame = CGRect(x: 0, y: 60 + 68, width: viewWidth, height: 40) sc1.segmentEdgeInset = UIEdgeInsets(top: 0, left: 10, bottom: 0, right: 10) sc1.selectionStyle = .FullWidthStripe sc1.selectionIndicatorLocation = .Down sc1.verticalDividerEnabled = true sc1.verticalDividerColor = .black sc1.verticalDividerWidth = 1.0 sc1.titleFormatter = &#123;(seg, title, index, selected) in let attString = NSAttributedString.init(string: title, attributes: [NSAttributedString.Key.foregroundColor : UIColor.blue]) return attString &#125; sc1.addTarget(self, action: #selector(segmentedControlChangedValue(segmentedControl:)), for: .valueChanged) view.addSubview(sc1) Demo③Style3： Code: 1234567891011121314151617sc1.addTarget(self, action: #selector(segmentedControlChangedValue(segmentedControl:)), for: .valueChanged)view.addSubview(sc1)// Segmented control with imageslet images: [UIImage] = [UIImage(named: &quot;1&quot;)!, UIImage(named: &quot;2&quot;)!, UIImage(named: &quot;3&quot;)!, UIImage(named: &quot;4&quot;)!]let selectedImages: [UIImage] = [UIImage(named: &quot;1-selected&quot;)!, UIImage(named: &quot;2-selected&quot;)!, UIImage(named: &quot;3-selected&quot;)!, UIImage(named: &quot;4-selected&quot;)!]let titles: [String] = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]let sc2 = EasySegmentedControl.init(with: images, sectionSelectedImages: selectedImages, sectiontitles: titles)sc2.imagePosition = .LeftOfTextsc2.frame = CGRect(x: 0, y: 120 + 68, width: viewWidth, height: 50)sc2.selectionIndicatorHeight = 4.0sc2.backgroundsColor = UIColor.clearsc2.selectionIndicatorLocation = .Downsc2.selectionStyle = .TextWidthStripesc2.segmentWidthStyle = .Dynamicsc2.addTarget(self, action: #selector(segmentedControlChangedValue(segmentedControl:)), for: .valueChanged)view.addSubview(sc2) Demo④Style4： Code: 1234567891011121314151617let sc3 = EasySegmentedControl.init(with: [&quot;one&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;4&quot;, &quot;Five&quot;]) sc3.frame = CGRect(x: 0, y: 180 + 68, width: viewWidth, height: 50) sc3.indexChangeBlock = &#123; index in print(&quot;Selected index \\(index) (via block)&quot;) &#125; sc3.selectionIndicatorHeight = 4.0 sc3.backgroundsColor = UIColor(red: 0.1, green: 0.4, blue: 0.8, alpha: 1) sc3.titleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white] sc3.selectionIndicatorColor = UIColor(red: 0.5, green: 0.8, blue: 1, alpha: 1) sc3.selectionIndicatorBoxColor = UIColor.black sc3.selectionIndicatorBoxOpacity = 1.0 sc3.selectionStyle = .Box sc3.selectedSegmentIndex = NoSegment sc3.selectionIndicatorLocation = .Down sc3.shouldAnimateUserSelection = false sc3.tag = 2 view.addSubview(sc3) Demo⑤Style5： Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253lazy var scrollView: UIScrollView = &#123; let s = UIScrollView.init(frame: CGRect(x: 0, y: 310 + 68, width: view.frame.size.width, height: 210)) s.backgroundColor = UIColor(red: 0.7, green: 0.7, blue: 0.7, alpha: 1) s.isPagingEnabled = true s.showsHorizontalScrollIndicator = false s.contentSize = CGSize(width: view.frame.size.width * 3, height: 200) s.delegate = self s.scrollRectToVisible(CGRect(x: view.frame.size.width, y: 0, width: view.frame.size.width, height: 200), animated: false) return s&#125;()override func viewDidLoad() &#123; super.viewDidLoad() let sc4 = EasySegmentedControl.init(frame: CGRect(x: 0, y: 260 + 68, width: view.frame.size.width, height: 50)) sc4.sectionTitles = [&quot;Worldwide&quot;, &quot;Local&quot;, &quot;Headlines&quot;] sc4.selectedSegmentIndex = 1 sc4.backgroundColor = UIColor(red: 0.7, green: 0.7, blue: 0.7, alpha: 1) sc4.titleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white] sc4.selectedTitleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor(red: 0.1, green: 0.1, blue: 0.1, alpha: 1)] sc4.selectionIndicatorColor = UIColor(red: 0.3, green: 0.3, blue: 0.3, alpha: 1) sc4.selectionStyle = .Box; sc4.selectionIndicatorLocation = .Up; sc4.tag = 3; sc4.indexChangeBlock = &#123;[weak self] index in if let strongSelf = self &#123; strongSelf.scrollView.scrollRectToVisible(CGRect(x: viewWidth * CGFloat(index), y: 0, width: viewWidth, height: 200), animated: true) &#125; &#125; view.addSubview(sc4) let lable1 = UILabel.init(frame: CGRect(x: 0, y: 0, width: viewWidth, height: 210)) setApperanceFor(label: lable1) lable1.text = &quot;Worldwide&quot; scrollView.addSubview(lable1) let lable2 = UILabel.init(frame: CGRect(x: viewWidth, y: 0, width: viewWidth, height: 210)) setApperanceFor(label: lable2) lable2.text = &quot;Local&quot; scrollView.addSubview(lable2) let lable3 = UILabel.init(frame: CGRect(x: viewWidth * 2, y: 0, width: viewWidth, height: 210)) setApperanceFor(label: lable3) lable3.text = &quot;Headlines&quot; scrollView.addSubview(lable3)&#125;func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123; let pageWidth = scrollView.frame.size.width let page = Int(scrollView.contentOffset.x / pageWidth) sc4.setSelectedSegment(index: page, animated: true)&#125; 您可根据自己的需要，调整参数达到UI设计的样式规范。","categories":[],"tags":[{"name":"UI","slug":"UI","permalink":"https://wsj2012.github.io/blog/tags/UI/"},{"name":"iOS","slug":"iOS","permalink":"https://wsj2012.github.io/blog/tags/iOS/"},{"name":"App","slug":"App","permalink":"https://wsj2012.github.io/blog/tags/App/"},{"name":"Swift","slug":"Swift","permalink":"https://wsj2012.github.io/blog/tags/Swift/"}]},{"title":"Flutter 纯iOS风格UI框架搭建","slug":"Flutter iOS风格UI框架搭建","date":"2019-03-28T05:49:30.000Z","updated":"2019-04-26T07:30:18.825Z","comments":true,"path":"article/Flutter iOS风格UI框架搭建/","link":"","permalink":"https://wsj2012.github.io/blog/article/Flutter iOS风格UI框架搭建/","excerpt":"","text":"新入门Flutter技术栈，从iOS转入，故实现一套全iOS风格的Flutter页面搭建。其中通过查询官方资料(现在生态不够健全，资料很难寻找)，花了点功夫最终得以实现。有实现更好的方式还望不吝赐教，有使用不对的地方还请指正。 Fetures: 全使用iOS风格widget（CupertinoTabBar搭配CupertinoTabScaffold） tabBar上菜单可自由设置显示风格（包括图标、字体大小颜色） Attention: 此入口类CupertinoTabScaffold内未设置navigationBar， navigationBar最好都在各自page页内设置，这样可自定制navigationBar上显示的不同元素。（如果在此入口类设置了navigationBar，各tab首页page的navigationBar上显示元素就会一致，个性化定制各page的navigationBar就需要加入更多的逻辑，建议navigationBar分散到各自的page页去实现） main.dart123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import &apos;package:flutter/cupertino.dart&apos;;import &apos;package:myapp/src/EngwordsPage.dart&apos;;import &apos;package:myapp/src/SamplePage.dart&apos;;import &apos;package:myapp/src/FirstPage.dart&apos;;import &apos;package:myapp/src/ListPage.dart&apos;;void main() =&gt; runApp(new MyApp());class MyApp extends StatefulWidget &#123; @override _MyMainState createState() =&gt; new _MyMainState();&#125;class _MyMainState extends State&lt;MyApp&gt; &#123; // 默认索引第一个tab int _tabIndex = 0; // 正常情况的字体样式 final tabTextStyleNormal = new TextStyle(color: const Color(0xff969696)); // 选中情况的字体样式 final tabTextStyleSelect = new TextStyle(color: const Color(0xff63ca6c)); // 底部菜单栏图标数组 var tabImages; // 页面内容 var _pages; // 菜单文案 var tabTitles = [&apos;推荐&apos;, &apos;资讯&apos;, &apos;发现&apos;, &apos;我的&apos;]; // 路由map Map&lt;String, WidgetBuilder&gt; _routes = new Map(); // 生成image组件 Image getTabImage(path) &#123; return new Image.asset(path, width: 20.0, height: 20.0); &#125; void initData() &#123; if (tabImages == null) &#123; tabImages = [ [ getTabImage(&apos;assets/images/ic_nav_news_normal.png&apos;), getTabImage(&apos;assets/images/ic_nav_news_actived.png&apos;) ], [ getTabImage(&apos;assets/images/ic_nav_tweet_normal.png&apos;), getTabImage(&apos;assets/images/ic_nav_tweet_actived.png&apos;) ], [ getTabImage(&apos;assets/images/ic_nav_discover_normal.png&apos;), getTabImage(&apos;assets/images/ic_nav_discover_actived.png&apos;) ], [ getTabImage(&apos;assets/images/ic_nav_my_normal.png&apos;), getTabImage(&apos;assets/images/ic_nav_my_pressed.png&apos;) ] ]; &#125; _pages = [ new EngwordsPage(), new SamplePage(), new ListWidget(&quot;发现&quot;), new FirstPage() ]; //获取菜单栏字体样式 TextStyle getTabTextStyle(int curIndex) &#123; if (curIndex == _tabIndex) &#123; return tabTextStyleSelect; &#125; else &#123; return tabTextStyleNormal; &#125; &#125; // 获取图标 Image getTabIcon(int curIndex) &#123; if (curIndex == _tabIndex) &#123; return tabImages[curIndex][1]; &#125; return tabImages[curIndex][0]; &#125; // 获取标题文本 Text getTabTitle(int curIndex) &#123; return new Text( tabTitles[curIndex], style: getTabTextStyle(curIndex), ); &#125; // 获取BottomNavigationBarItem List&lt;BottomNavigationBarItem&gt; getBottomNavigationBarItem() &#123; List&lt;BottomNavigationBarItem&gt; list = new List(); for (int i = 0; i &lt; 4; i++) &#123; list.add(new BottomNavigationBarItem( icon: getTabIcon(i), title: getTabTitle(i))); &#125; return list; &#125; @override Widget build(BuildContext context) &#123; initData(); return new CupertinoApp( title: &quot;Demo&quot;, theme: new CupertinoThemeData( primaryColor: CupertinoColors.darkBackgroundGray, ), routes: _routes, home: new CupertinoTabScaffold( tabBar: CupertinoTabBar( items: getBottomNavigationBarItem(), currentIndex: _tabIndex, onTap: (index) &#123; setState(() &#123; _tabIndex = index; &#125;); &#125;, ), tabBuilder: (BuildContext context, int index) &#123; return CupertinoTabView( builder: (BuildContext context) &#123; return CupertinoPageScaffold( child: _pages[index], // navigationBar: CupertinoNavigationBar( // middle: Text(tabTitles[index]), // trailing: _trailingButtons[index], // ), ); &#125;, ); &#125;, ), ); &#125;&#125; FirstPage.dart12345678910111213141516171819202122232425262728293031323334353637import &apos;package:flutter/cupertino.dart&apos;;class FirstPage extends StatefulWidget &#123; @override FirstPageState createState() =&gt; new FirstPageState();&#125;class FirstPageState extends State&lt;FirstPage&gt; &#123; final rt = new CupertinoButton( child: new Image.asset(&quot;assets/images/nav_close.png&quot;), onPressed: () &#123; print(&quot;right clicked&quot;); &#125;, ); @override Widget build(BuildContext context) &#123; return new CupertinoPageScaffold( navigationBar: CupertinoNavigationBar( middle: Text(&quot;First&quot;), trailing: rt, border: Border.all(width: 0, color: CupertinoColors.darkBackgroundGray), ), child: new Container( child: new Center( child: new Text( &quot;这是第一个界面&quot;, style: new TextStyle( color: CupertinoColors.darkBackgroundGray, fontSize: 18, ), ), ), ), ); &#125;&#125; 其他类（EngwordsPage.dart、SamplePage.dart）都是如此的UI结构。 Effects：","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://wsj2012.github.io/blog/tags/Flutter/"},{"name":"UI","slug":"UI","permalink":"https://wsj2012.github.io/blog/tags/UI/"},{"name":"iOS","slug":"iOS","permalink":"https://wsj2012.github.io/blog/tags/iOS/"},{"name":"App","slug":"App","permalink":"https://wsj2012.github.io/blog/tags/App/"}]}]}